{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "97072692",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import scipy.linalg as la"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3ea56ecc",
   "metadata": {},
   "source": [
    "## Function to generate the FPE operator matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "53eed77c",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Classical implementation\n",
    "\"\"\"\n",
    "Purpose: \n",
    "    Find the analytical solution given the input parameters\n",
    "Input: \n",
    "    x: array representing the x coordinates over which the solution is to be found\n",
    "    a, Γ: parameters for the Ornstein-Uhlenbeck equation\n",
    "Output:\n",
    "    y: array of the value of the analytical solution over x\n",
    "\"\"\"\n",
    "\n",
    "def OrnsteinUhlenbeck(x, a = 1, gamma = 1):\n",
    "    y = np.sqrt(a/(2*np.pi*gamma)) * np.exp((-a * x ** 2)/(2*gamma))\n",
    "    \n",
    "    return y\n",
    "\n",
    "\"\"\"\n",
    "Purpose:\n",
    "    Calculate the weighted Hermite polynomials using recursive relations up to H_n\n",
    "Input:\n",
    "    n: the highest number of Hermite polynomials to be evaluated at\n",
    "    x: the value of x at which the weighted Hermite polynomials are to be evaluated\n",
    "Output:\n",
    "    Hermite: the value of the weighted Hermite polynomials\n",
    "Example: HermiteSeries(2, 4) -> [H_0(4), H_1(4), H_2(4)]\n",
    "\"\"\"\n",
    "\n",
    "def HermiteSeries(n, x):\n",
    "    Hermite = np.zeros((1, n+1))\n",
    "    Hermite[0][0] = 1.0 * np.exp(-x**2/2)\n",
    "    Hermite[0][1] = 2.0 * x *np.exp(-x**2/2)\n",
    "    \n",
    "    for ni in range(1, n):\n",
    "        Hermite[0][ni+1] = 2*x*Hermite[0][ni] - 2*ni*Hermite[0][ni-1]\n",
    "    \n",
    "    return Hermite\n",
    "\n",
    "\"\"\"\n",
    "Purpose:\n",
    "    Reconstruct the functions represented by the coefficients of weighted Hermite polynomials in spatial coordinates\n",
    "Input:\n",
    "    x: array containing the x values over which the function is to be evaluated\n",
    "    coefficients: the coefficients corresponding to the Hermite polynomials (should be zero-mode of the operator)\n",
    "    nmax: the highest order of weighted Hermite polynomials used\n",
    "    s: the scaling factor\n",
    "Output:\n",
    "    y: the reconstruction\n",
    "\"\"\"\n",
    "\n",
    "def project(x, coefficients, nmax, s):\n",
    "    \n",
    "    y = np.zeros(x.shape)\n",
    "    \n",
    "    for i in (range(len(x))):\n",
    "        x0 = s*x[i]\n",
    "        hermite_values = HermiteSeries(nmax, x0)\n",
    "        y[i] += np.dot(hermite_values, coefficients)\n",
    "        \n",
    "    return (x, y)\n",
    "\n",
    "\"\"\"\n",
    "Purpose:\n",
    "    Normalize the PDF so that the area under the curve is 1\n",
    "Input:\n",
    "    x, y: arrays representing the unnormalized\n",
    "Output:\n",
    "    (x, y): normalized PDF\n",
    "\"\"\"\n",
    "\n",
    "def normalize(x, y):\n",
    "    dx = x[1] - x[0]\n",
    "    sum = 0\n",
    "    \n",
    "    for i in range(len(x)):\n",
    "        sum = sum + (y[i] * dx)\n",
    "    \n",
    "    y = y/sum\n",
    "    \n",
    "    return (x, y)\n",
    "\n",
    "\"\"\"\n",
    "Purpose:\n",
    "    Calculate the RMS\n",
    "Input:\n",
    "    y_op, y: the y values generated by the operator and the analytical solution\n",
    "Output:\n",
    "    RMS\n",
    "\"\"\"\n",
    "\n",
    "def rms_diff(y_op, y):\n",
    "    return np.sqrt(np.sum((y_op-y)**2)/len(y))\n",
    "\n",
    "\"\"\"\n",
    "Purpose:\n",
    "    Find s given a and Γ such that the projection in Hermite space is just H_0\n",
    "Input:\n",
    "    a, Γ: parameters for Ornstein-Uhlenbeck\n",
    "Output:\n",
    "    s\n",
    "\"\"\"\n",
    "\n",
    "def special_s(a, gamma):\n",
    "    return np.sqrt(a/gamma)\n",
    "\n",
    "def euler_representation(z):\n",
    "    A = abs(z)\n",
    "    phase = math.atan(z.imag/z.real)\n",
    "    \n",
    "    return A, phase\n",
    "\n",
    "def generate_positive_semidefinite_matrix(eigenvalues):\n",
    "    ## Function to transform the FPE operator to the Hermite basis and return a finite truncated matrix for the ...\n",
    "    ## ... FPE operator\n",
    "    \n",
    "    n = len(eigenvalues)\n",
    "    s = np.diag(eigenvalues)\n",
    "    q, _ = la.qr(np.random.rand(n, n))\n",
    "    semidef = np.dot(np.transpose(q), s)\n",
    "    semidef = np.dot(semidef, q)\n",
    "    \n",
    "    return semidef\n",
    "\n",
    "def normalize_probability(y, dx):\n",
    "    ## Function to return a normalized PDF \n",
    "    \n",
    "    total = np.sum(y) * dx\n",
    "    y = y / total\n",
    "    \n",
    "    return y\n",
    "\n",
    "def perturbed_ornstein_uhlenbeck(x0, a = 1, gamma = 1, c = 0, shift = 0):\n",
    "    ## Function to compute the exact solution to the perturbed Ornstein-Uhlenbeck equation\n",
    "    \n",
    "    assert len(x0) > 1, \"Error: x0 should be a vector\"\n",
    "\n",
    "    x = x0 - shift\n",
    "    y = np.exp(-a*x**2 /(2*gamma) - c*x**4 /(4*gamma))\n",
    "    dx = x[2] - x[1]\n",
    "    \n",
    "    y = normalize_probability(y, dx)\n",
    "    \n",
    "    return y\n",
    "\n",
    "def special_L(a, gamma):\n",
    "    ## Function to compute the characteristic length scale\n",
    "    \n",
    "    return np.sqrt(a/gamma)\n",
    "\n",
    "def delta(N, n):\n",
    "    ## Function to implement the Kronecker delta function\n",
    "    \n",
    "    if N == n:\n",
    "        return 1\n",
    "    else:\n",
    "        return 0\n",
    "\n",
    "def f(N,n):\n",
    "    return 0.5*( np.sqrt(n*(n-1))*delta(N,n-2) + delta(N,n) - np.sqrt((n+1)*(n+2))*delta(N,n+2))\n",
    "\n",
    "def g(N,n, L):\n",
    "    return 0.5*L**2*( np.sqrt(n*(n-1))*delta(N,n-2) - (2*n+1)*delta(N,n) + np.sqrt((n+1)*(n+2))*delta(N,n+2))\n",
    "\n",
    "def t(N, n, L):\n",
    "    val1 = np.sqrt(n*(n-1)*(n-2)*(n-3))*delta(N, n-4)\n",
    "    val2 = (2*n+2)*np.sqrt(n*(n-1))*delta(N, n-2)\n",
    "    val3 = (6*n+3)*delta(N, n)\n",
    "    val4 = -2*n*np.sqrt((n+1)*(n+2))*delta(N, n+2)\n",
    "    val5 = -1*np.sqrt((n+1)*(n+2)*(n+3)*(n+4))*delta(N, n+4)\n",
    "\n",
    "    return 1/(4*L**2)*( val1 + val2 + val3 + val4 + val5 )\n",
    "\n",
    "def element_perturbed(N, n, L, a, c, gamma):\n",
    "    ## Function to compute the matrix elements of the finite truncated matrix for the FPE operator (in the Hermite basis)\n",
    "    \n",
    "    return -(a*f(N,n) + c*t(N, n, L) + gamma*g(N, n, L))\n",
    "\n",
    "def create_operator_perturbed(nmax, L, a, c, gamma):\n",
    "    ## Function to generate the FPE operator matrix in the Hermite basis\n",
    "    op = np.zeros((nmax+1, nmax+1))\n",
    "    \n",
    "    for N in range(nmax+1):\n",
    "        row = N\n",
    "        for n in range(nmax+1):\n",
    "            col = n\n",
    "            op[row, col] = element_perturbed(N, n, L, a, c, gamma)\n",
    "    \n",
    "    \"\"\"\n",
    "    if np.any(np.nan, op):\n",
    "        print(\"There's an nan in the operator\")\n",
    "    elif np.any(np.inf, op):\n",
    "        print(\"There is an inf in the operator\")\n",
    "    \"\"\"\n",
    "\n",
    "    return op\n",
    "\n",
    "def state_n(nmax, x0, L):\n",
    "    ## Function to compute the Hermite polynomials upto the order specified by nmax\n",
    "    \n",
    "    assert L > 0, \"Error (state_n): input L must be greater than or equal to 0\"\n",
    "\n",
    "    states = np.zeros(nmax + 1)\n",
    "    x = x0*L\n",
    "\n",
    "    states[0] = np.sqrt(L*np.sqrt(1/np.pi))* 1.0 * np.exp(-x**2/2)\n",
    "\n",
    "    if nmax > 0:\n",
    "        states[1] = np.sqrt(L*np.sqrt(1/np.pi))* (1/np.sqrt(2)) * 2.0 * x * np.exp(-(x**2)/2)\n",
    "    \n",
    "    for ni in range(2, nmax + 1):\n",
    "        states[ni] = ((np.sqrt(2)*x) / np.sqrt(ni))*states[ni-1] - (ni-1)/np.sqrt((ni)*(ni-1))*states[ni-2]\n",
    "\n",
    "    return states\n",
    "\n",
    "def integrate_eigenvector(x0, y, nmax, L):\n",
    "    ## Function to compute the coefficients corresponding to the calculated Hermite polynomials by numerical integration\n",
    "    ## Note: here, we use the left-hand integration method\n",
    "    \n",
    "    dx = x0[2] - x0[1]\n",
    "    eigenvector = np.zeros(nmax + 1)\n",
    "\n",
    "    for i in range(len(x)):\n",
    "\n",
    "        states = state_n(nmax, x0[i], L)\n",
    "        states = states * y[i] * dx\n",
    "\n",
    "        eigenvector = eigenvector + states\n",
    "        \n",
    "    return {\"eigenvector\" : eigenvector, \"dx\" : dx, \"nmax\" : nmax, \"x0\" : x0, \"L\" : L}\n",
    "\n",
    "def make_operator_even(op):\n",
    "    op_new = np.zeros((op.shape[0]//2, op.shape[1]//2))\n",
    "    \n",
    "    for row in range(op_new.shape[0]):\n",
    "        for col in range(op_new.shape[1]):\n",
    "            op_new[row, col] = op[row*2, col * 2]\n",
    "    \n",
    "    return op_new\n",
    "\n",
    "def reconstruct_eigenvector(cache, normalize = True, only_even = False):\n",
    "    ## Function to reconstruct the PDF using the cache obtained previously\n",
    "    \n",
    "    eigenvector = cache[\"eigenvector\"]\n",
    "    nmax = cache[\"nmax\"]\n",
    "    x0 = cache[\"x0\"]\n",
    "    dx = cache[\"dx\"]\n",
    "    L = cache[\"L\"]\n",
    "    \n",
    "    if not only_even:\n",
    "        eigenvector = cache[\"eigenvector\"]\n",
    "    else:\n",
    "        eigenvector_old = cache[\"eigenvector\"]\n",
    "        eigenvector = np.zeros(nmax + 1)\n",
    "        \n",
    "        for i in range(len(eigenvector_old)):\n",
    "            eigenvector[2*i] = eigenvector_old[i]\n",
    "\n",
    "    y = np.zeros(len(x0))\n",
    "\n",
    "    for i in range(len(x0)):\n",
    "        states = state_n(nmax, x0[i], L)\n",
    "        y[i] += (np.dot(states, eigenvector))\n",
    "    if normalize:   \n",
    "        y = normalize_probability(y, dx)\n",
    "        \n",
    "    return (x0, y)\n",
    "\n",
    "def find_zeromode(op_nonhermitian, nmax, x0, dx, L, which = \"single\", only_even = False):\n",
    "    ## Function to compute the zeromode, its position, and the eigenvalue corresponding to the zeromode\n",
    "    \n",
    "    assert which == \"nonhermitian\" or which == \"single\", \"Error: currently only supports which = {\\\"nonhermitian\\\", \\\"single\\\"}\"\n",
    "    \n",
    "    if only_even:\n",
    "        op_processed = make_operator_even(op_nonhermitian)\n",
    "    else:\n",
    "        op_processed = op_nonhermitian\n",
    "        \n",
    "    if which == \"nonhermitian\":\n",
    "        op = op_processed\n",
    "    elif which == \"single\":\n",
    "        op = np.dot(np.transpose(op_processed), op_processed)\n",
    "\n",
    "    eigenvalues, eigenvectors = la.eig(op)\n",
    "\n",
    "    index = np.argmin(np.real(eigenvalues)**2)\n",
    "\n",
    "    min_eigenval = eigenvalues[index]\n",
    "    \n",
    "    zeromode = eigenvectors[:, index]\n",
    "\n",
    "    return {\"operator\" : op, \"which\" : which, \\\n",
    "            \"eigenvector\" : np.real(zeromode), \"index\" : index, \"eigenvalue\" : np.real(min_eigenval), \\\n",
    "            \"nmax\" : nmax, \"x0\" : x0, \"dx\" : dx, \"L\" : L, \"spectrum\" : eigenvalues, \"P\" : eigenvectors}\n",
    "\n",
    "def rms_diff(y0, y, sigdigits = 0):\n",
    "    ## Function to compute the RMS difference between the analytically computed PDF and the one ...\n",
    "    ## ... obtained using the FPE operator\n",
    "    \n",
    "    assert len(y0) == len(y), \"Error: the length of y0 and y should be the same\"\n",
    "    diff = np.sum((y0-y)**2)/len(y0)\n",
    "    \n",
    "    return np.sqrt(diff)\n",
    "\n",
    "def analyze_collapse(initial_state, P, index):\n",
    "    num_basis = P.shape[1]\n",
    "    coefficients = np.zeros((num_basis, ))\n",
    "\n",
    "    for i in range(num_basis):\n",
    "        basis = P[:, i]\n",
    "        basis = normalize_eigenvector(basis)\n",
    "\n",
    "        coefficients[i] = np.dot(basis, initial_state)\n",
    "\n",
    "    normalized_coefficients = normalize_eigenvector(coefficients)\n",
    "\n",
    "    reconstruction = np.zeros((P.shape[0], ))\n",
    "\n",
    "    for i in range(num_basis):\n",
    "        basis = P[:, i]\n",
    "        basis = normalize_eigenvector(basis)\n",
    "\n",
    "        added_vector = coefficients[i] * basis\n",
    "        reconstruction = reconstruction + added_vector\n",
    "\n",
    "    probability = normalized_coefficients ** 2\n",
    "    \n",
    "    probability_zeromode = probability[index]\n",
    "    assert np.sum(probability) - 1 < 0.00001, \"Error: unity normalization of probability is not observed\"\n",
    "\n",
    "    print(\"The initial_state is: \")\n",
    "    print(initial_state)\n",
    "    print()\n",
    "\n",
    "    print(\"The coefficient expansion is: \")\n",
    "    print(coefficients)\n",
    "    print()\n",
    "\n",
    "    print(\"The normalized coefficient expansion is: \")\n",
    "    print(normalized_coefficients)\n",
    "    print()\n",
    "\n",
    "    print(\"The reconstructed vector is: \")\n",
    "    print(reconstruction)\n",
    "    print()\n",
    "\n",
    "    print(\"The probability of collapsing into each eigenvector is: \")\n",
    "    print(probability)\n",
    "    print()\n",
    "\n",
    "    print(\"The probability of collapsing into the zeromode is: \")\n",
    "    print(probability_zeromode)\n",
    "    print()\n",
    "    \n",
    "    return probability_zeromode, probability"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3cdd213c",
   "metadata": {},
   "source": [
    "## Construct the FPE operator matrix (case 1; IBM Nairobi; 4 precision qubits)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "51822da1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Defining FPE parameters\n",
    "nmax = 15\n",
    "dx = 0.01\n",
    "a = 10\n",
    "gamma = 2\n",
    "c = 3\n",
    "L = 2\n",
    "shift = 0\n",
    "\n",
    "## Finding the zeromode through diagonalization\n",
    "op_nonhermitian = create_operator_perturbed(nmax, L, a, c, gamma)\n",
    "only_even = True\n",
    "\n",
    "# Construct the perturbed Orsntein-Uhlenbeck solution\n",
    "x = np.linspace(-5, 5, int((10)/dx))\n",
    "y = perturbed_ornstein_uhlenbeck(x, a = a, gamma = gamma, c = c, shift = shift)\n",
    "\n",
    "cache_diagonalization = find_zeromode(op_nonhermitian, nmax, x, dx, L, which = \"single\", only_even = only_even)\n",
    "x_diagonalization, y_diagonalization = reconstruct_eigenvector(cache_diagonalization, only_even = only_even)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "36951545",
   "metadata": {},
   "source": [
    "## Generate the FPE operator matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "be523c77",
   "metadata": {},
   "outputs": [],
   "source": [
    "Q = cache_diagonalization['operator']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "09a7a393",
   "metadata": {},
   "source": [
    "## Function to compute the expectation value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7984fdb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_expectation(Q, zeromode):\n",
    "    # Function to compute the steady-state expectation value of the FPE operator\n",
    "    \n",
    "    value = np.dot(Q, zeromode)\n",
    "    expectation_val = np.dot(np.transpose(zeromode), value)\n",
    "    \n",
    "    return expectation_val"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5c30a6e0",
   "metadata": {},
   "source": [
    "## FPE operator steady-state expectation values"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4dbbb258",
   "metadata": {},
   "source": [
    "### Classical result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "67df1be7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[1.11216132e-05]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_classic = [[ 9.94059138e-01], [-1.08702764e-01], [ 1.65627715e-03], [ 4.87619708e-03], [-1.88428944e-03], [ 2.26921154e-04], [ 6.83588404e-05], [-1.07365649e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_classic)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "158a76ee",
   "metadata": {},
   "source": [
    "### Quantum results"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ecee5aca",
   "metadata": {},
   "source": [
    "#### In the absence of DD"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "1132dec8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00052593]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.14444780e-01], [-8.90311599e-02], [ 1.38639554e-03], [ 4.00131615e-03], [-1.49590441e-03], [ 6.67554123e-05], [ 1.13512215e-04], [-1.18401615e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3a1b9bb",
   "metadata": {},
   "source": [
    "#### In the presence of DD"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b8f0c577",
   "metadata": {},
   "source": [
    "#### For the Hahn-X sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "5d3d23f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00052371]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 7.8461939e-01], [-8.5767880e-02], [ 1.3363472e-03], [ 3.8580217e-03], [-1.4379339e-03], [ 5.5955050e-05], [ 1.0346633e-04], [-1.1884168e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33fcd7ba",
   "metadata": {},
   "source": [
    "#### For the Hahn-Y sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "82b002fe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00052371]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 7.8461939e-01], [-8.5767880e-02], [ 1.3363472e-03], [ 3.8580217e-03], [-1.4379339e-03], [ 5.5955050e-05], [ 1.0346633e-04], [-1.1884168e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "564cb490",
   "metadata": {},
   "source": [
    "#### For the CP sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "6c0dfd35",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e1a93c01",
   "metadata": {},
   "source": [
    "#### For the CPMG sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "e3d693b2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ba789104",
   "metadata": {},
   "source": [
    "#### For the XYXY sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "8ac3bbc1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4236b87",
   "metadata": {},
   "source": [
    "#### For the YZYZ sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "e400aaf8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c8d741e9",
   "metadata": {},
   "source": [
    "#### For the XZXZ sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "b5a37ca3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a354c75",
   "metadata": {},
   "source": [
    "#### For the CDD sequence (order 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "f50bdaaf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7dbe36ce",
   "metadata": {},
   "source": [
    "#### For the XY8 sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "ab16b85e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "239b8186",
   "metadata": {},
   "source": [
    "#### For the XY16 sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "08dfebdf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dfc1e51a",
   "metadata": {},
   "source": [
    "#### For the Uhrig-X sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "965da53f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d1fa3a62",
   "metadata": {},
   "source": [
    "#### For the Uhrig-Y sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "e6ec1e43",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00155362]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4916246e-01], [-9.2803702e-02], [ 1.4547575e-03], [ 4.1766865e-03], [-1.5264461e-03], [-3.5735153e-05], [ 1.1750075e-04], [-1.4897472e-04]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39f4a2ee",
   "metadata": {},
   "source": [
    "#### For the KDD sequence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "3042fda0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The expectation value of the FPE operator wrt the zeromode is:\n",
      "[[0.00027551]]\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Get the zeromode\n",
    "zeromode_qpe = [[ 8.4073013e-01], [-9.1831118e-02], [ 1.4655363e-03], [ 4.1124821e-03], [-1.5702489e-03], [ 1.3899177e-04], [ 1.2629881e-04], [-9.3024457e-05]]\n",
    "\n",
    "# Compute the expectation value\n",
    "expectation_value = get_expectation(Q, zeromode_qpe)\n",
    "\n",
    "# Print the expectation value\n",
    "print('The expectation value of the FPE operator wrt the zeromode is:')\n",
    "print(expectation_value)\n",
    "print()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
